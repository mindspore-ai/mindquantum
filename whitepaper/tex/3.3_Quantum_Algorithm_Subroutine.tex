In the \library module of \MindQuantum, we implement some common components of quantum algorithms.

\begin{itemize}

    \item \amplitudeencoder: Quantum circuit for amplitude encoding.

    \item \bitphaseflipoperator: Generate a circuit that can flip the sign of any calculation bases.

    \item \generalghzstate: Circuit that prepare a general GHZ state based on zero state. The GHZ state is defined as the equality superposition of three zeros state and three ones state:

          \begin{equation}
              \left|\text{GHZ}\right> = (\left|000\right> + \left|111\right>)/\sqrt{2}.
          \end{equation}

          Here in this API, we can create a general GHZ state on arbitrary sub qubits of any total qubits.

    \item \generalwstate: General W state. The W state is defined as the equality superposition of bases that only one qubit is in $|1\rangle$
          while others qubits are in $|0\rangle$
          . For example, a three qubits W state is defined as:

          \begin{equation}
              \left|\rm W\right> = (\left|001\right> + \left|010\right> + \left|100\right>)/\sqrt{3}.
          \end{equation}

          Here in this API, we can define a W state on any sub Hilbert space of any total number qubits.

    \item \qft: Quantum Fourier Transform (QFT). The function of the quantum Fourier transform is similar to that of the classical Fourier transform.
\end{itemize}

Taking \amplitudeencoder as an example, you can use it when building a quantum algorithm like this:
\begin{lstlisting}
from mindquantum.algorithm.library import amplitude_encoder
from mindquantum.simulator import Simulator
sim = Simulator('mqvector', 8)
encoder, parameterResolver = amplitude_encoder([0.5, -0.5, 0.5, 0.5], 8)
sim.apply_circuit(encoder, parameterResolver)
\end{lstlisting}
Their return value is just a circuit, so you can add it into your algorithm wherever needed.