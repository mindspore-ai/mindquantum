In the $libaray$ module of \MindQuantum, we implement some common components of quantum algorithms.

\begin{itemize}

    \item $amplitude\_encoder$: Quantum circuit for amplitude encoding.

    \item $bitphaseflip\_operator$: Generate a circuit that can flip the sign of any calculation bases.

    \item $general\_ghz\_state$: Circuit that prepare a general GHZ State based on zero state. The GHZ State is defined as the equality superposition of three zeros state and three ones state:

    \begin{equation}
        \left|\text{GHZ}\right> = (\left|000\right> + \left|111\right>)/\sqrt{2}.
    \end{equation}

    Here in this API, we can create a general GHZ state on arbitrary sub qubits of any total qubits.

    \item $general\_w\_state$: General W State. The W State is defined as the equality superposition of bases that only one qubit is in ∣∣1⟩
     while others qubits are in |0⟩
    . For example, a three qubits W state is defined as:

    \begin{equation}
        \left|\rm W\right> = (\left|001\right> + \left|010\right> + \left|100\right>)/\sqrt(3).
    \end{equation}

    Here in this API, we can define a W state on any sub Hilbert space of any total number qubits.

    \item $qft$: Quantum Fourier Transform (QFT). The function of the quantum Fourier transform is similar to that of the classical Fourier transform.
\end{itemize}

Taking $amplitude\_encoder$ as an example, you can use it when building a quantum algorithm like this:
\begin{lstlisting}
from mindquantum.algorithm.library import amplitude_encoder
from mindquantum.simulator import Simulator
sim = Simulator('mqvector', 8)
encoder, parameterResolver = amplitude_encoder([0.5, -0.5, 0.5, 0.5], 8)
sim.apply_circuit(encoder, parameterResolver)
\end{lstlisting}
Their return value is just a circuit, so you can add it into your algorithm wherever needed.