Simulating many-body physical systems was proposed by Richard Feynman as a main application for quantum computation. Among the various many-body physics models, we focus on the Heisenberg model and the Fermi-Hubbard model. The Hamiltonians for these models can be expressed as follows:

\begin{align*}
    H_\text{Heisenberg}    & = -J\sum_{<i,j>}\sigma_i\otimes \sigma_j-h\sum_i\sigma_i,                                            \\
    H_\text{Fermi-Hubbard} & = -\sum_{<i,j>,\sigma}\left(a_{i\sigma}^\dagger a_{j\sigma} + a_{j\sigma}^\dagger a_{i\sigma}\right) \\
                           & + U\sum_i n_{i\uparrow}n_{i\downarrow}.
\end{align*}

In \MindQuantum, it is easy to construct those Hamiltonian with the help of \QubitOperator and \FermionOperator.

\subsubsection{Qubit Operators}

In Heisenberg model, $\sigma_i$ represents the Pauli operator. The matrix form of Pauli operators are:

\begin{align*}
    \sigma_X & = \begin{pmatrix}
        0 & 1 \\
        1 & 0
    \end{pmatrix}, \sigma_Y = \begin{pmatrix}
        0 & -i \\
        i & 0
    \end{pmatrix}, \\
    \sigma_I & =\begin{pmatrix}
        1 & 0 \\
        0 & 1
    \end{pmatrix}, \sigma_Z = \begin{pmatrix}
        1 & 0  \\
        0 & -1
    \end{pmatrix}.
\end{align*}
In \MindQuantum, \QubitOperator is used to build this kind of operator. Given a Pauli word $\sigma_{X,3}\otimes \sigma_{Y,1}\otimes \sigma_{Z,0}=X_3 Y_1 Z_0$, applying Pauli $Z$, Pauli $Y$ and Pauli $X$ on qubit 3, 1 and 0,  we can easily construct it with:

\begin{lstlisting}
from mindquantum.core.operators import QubitOperator

ops = QubitOperator('Z0 Y1 X3')
\end{lstlisting}
Please note that since $[Z_0, Y_1]= [Z_0,X_3] = [Y_1, X_3]=0$, so the order of Pauli word in the Pauli string does not matter.

\QubitOperator also support arithmetic operations, in order to build more complex operators:

\begin{lstlisting}
from mindquantum.core.operators import QubitOperator
from mindquantum.core.parameterresolver import ParameterResolver as PR

op1 = QubitOperator('X0')
op2 = QubitOperator('Z1', 'a')
op3 = QubitOperator('Y1')
op4 = 2 * op1 * op2 + op3 * PR('b')
print(op4)
print(op4.subs({'a':1, 'b':2}).matrix().toarray())
\end{lstlisting}
The output is:
\begin{lstlisting}
2*a [X0 Z1] +
  b [Y1]

[[ 0.+0.j  2.+0.j  0.-2.j  0.+0.j]
 [ 2.+0.j  0.+0.j  0.+0.j  0.-2.j]
 [ 0.+2.j  0.+0.j  0.+0.j -2.+0.j]
 [ 0.+0.j  0.+2.j -2.+0.j  0.+0.j]]
\end{lstlisting}
In the last line, we used \code{.subs} to set the value of parameters and obtained the CSR format sparse matrix with \code{.matrix}.

\subsubsection{Fermion Operators}

In Fermi-Hubbard model, $a_i^\dagger$ and $a_i$ are creation and annihilation operators for fermionic particles. Different from Pauli operators, the fermion operator follows anti-commutation relation:
\begin{align*}
    \{a_i, a_j^\dagger\} & = a_ia_j^\dagger + a_j^\dagger a_i = \delta_{ij}, \\
    \{a_i, a_j\}         & = \{a_i^\dagger, a_j^\dagger\}=0.
\end{align*}
In qubit system, the creation and annihilation operators acting on state $\ket{0}$ and $\ket{1}$ obey the following rules:
\begin{align*}
    a\ket{0}          & =0,        & a\ket{1}          & =\ket{0}, \\
    a^\dagger \ket{0} & = \ket{1}, & a^\dagger \ket{1} & =0.
\end{align*}

The matrix forms of the creation and annihilation operators are:

\begin{align*}
    a=\begin{pmatrix}
        0 & 1 \\
        0 & 0
    \end{pmatrix},
    a^\dagger=\begin{pmatrix}
        0 & 0 \\
        1 & 0
    \end{pmatrix}.
\end{align*}
In \MindQuantum, we can use \FermionOperator to construct fermion operator. Suppose we first create a state on qubit 1 and annihilate a state on qubit 0, or $a_1^\dagger\otimes a_0$, one can build it with:
\begin{lstlisting}
from mindquantum.core.operators import FermionOperator
op1 = FermionOperator('1^ 0')
\end{lstlisting}
In the fermion string, we use \verb|^| to represent $\dagger$ and the number to label the corresponding qubit. The arithmetic operation of \FermionOperator is very similar to \QubitOperator.


\subsubsection{Operator Functions}

\MindQuantum\ also supplies a number of advanced functions for operators. Here are some examples:

- \methodcommutator{op1}{op2} : Output the commutator of two operators.

\begin{lstlisting}
from mindquantum.core.operators import QubitOperator, FermionOperator, commutator
qub_op1 = QubitOperator("X1 Y2")
qub_op2 = QubitOperator("X1 Z2")
commutator(qub_op1, qub_op1)  # 0
commutator(qub_op1, qub_op2)  # (2j) [X2]
\end{lstlisting}

- \methodcountqubits{op1} : Count the number of qubits before deleting unused qubits.

\begin{lstlisting}
from mindquantum.core.operators import QubitOperator,FermionOperator, count_qubits
qubit_op = QubitOperator("X1 Y2")
count_qubits(qubit_op)  # 3
fer_op = FermionOperator("1^")
count_qubits(fer_op)  # 2
\end{lstlisting}


- \methodhermitianconj{op1} : Get the hermitian conjugation of given operator.

\begin{lstlisting}
from mindquantum.core.operators import FermionOperator, hermitian_conjugated
fer_op = FermionOperator("1^ 3")
hermitian_conjugated(fer_op)
\end{lstlisting}

\subsubsection{Transformation}
Quantum simulation of fermionic systems is challenging. To effectively reduce the resources used to simulate fermionic Hamiltonians on quantum hardware, we can simulate fermions with qubits, which involves the conversion between the fermionic Hamiltonian and the qubit Hamiltonian. \MindQuantum\ supplies the module \code{mindquantum.algorithm.nisq.Transform} for transformation between fermions (\FermionOperator) and bosons (\QubitOperator). The following functions are provided:
\begin{itemize}
    \item \methodjordanwigner: Apply the Jordan-Wigner transformation, which maps fermionic annihilation operators (fermions) to qubits (bosons) via:
          \begin{equation}
              \begin{split}
                  a_j^{\dagger} \to {\sigma}_j^{-} X \prod_{i=0}^{j-1} {\sigma}^Z_i \\
                  a_j \to {\sigma}_j^{+} X \prod_{i=0}^{j-1} {\sigma}^Z_i,
              \end{split}
          \end{equation}
          where ${\sigma}_j^{+} = {\sigma}_j^X+i{\sigma}_j^Y$, ${\sigma}_j^{-} = {\sigma}_j^X-i{\sigma}_j^Y$, are the spin-up operator and spin-down operator respectively. The operator $\prod_{i=0}^{p-1} {{\sigma}^Z_i}$ is called a ``parity operator'' with eigenvalues $\pm 1$, because it measures whether the number of qubits in the down state (or ``$-1$'' state) from index 0 to $p-1$ is even or odd. If the number is even, the operator yields $+1$; if odd, it yields $-1$. This transformation preserves the locality of the initial occupation number. The problem with this method is that as a consequence of the non-locality of the parity operator, the number of extra qubit operations required to simulate a single fermionic operator scales as $O(n)$.
    \item \methodparity: Apply the parity transformation, which uses qubit $j$ to store the $parity$ of all occupied orbitals up to orbital $j$. That is, we could let qubit $j$ store $p_j = (\sum_{i=0}^j f_i) mod 2$. Here, $f_i$ represents the occupation number of the $i$-th orbital, which can be either 0 (unoccupied) or 1 (occupied). This encoding of fermionic states in qubit states is called the $parity$ basis. The occupation number basis states, which can be represented as vectors (e.g. $(j_7,...,j_1,j_0)^T$), can be mapped to the parity basis as follows:
          \begin{equation}
              p_i = \sum_j {[\pi_n]_{ij} f_j},
          \end{equation}
          where $n$ is the number of orbitals, $\pi_n$ is the ($n \times n$) matrix defined below:
          \begin{equation}
              [\pi_n]_{ij} =
              \begin{cases}
                  1 & i<j     \\
                  0 & i\geq j \\
              \end{cases}.
          \end{equation}
          The representations of the creation and annihilation operators in the parity basis are then:
          \begin{equation}
              \begin{split}
                  a_j^{\dagger} \to \frac{1}{2} (\prod_{i=j+1}^n ({\sigma}^X_i X))({\sigma}^X_j - i{\sigma}^Y_j) X {\sigma}^Z_{j-1} \\
                  a_j \to \frac{1}{2} (\prod_{i=j+1}^n ({\sigma}^X_i X))({\sigma}^X_j + i{\sigma}^Y_j) X {\sigma}^Z_{j-1}.
              \end{split}
          \end{equation}
    \item \methodbravyikitaev \cite{bravyi2002fermionic, fenwick1994new}: The previous two approaches are dual in the sense that they encode the information required to represent fermionic operators with qubits. With the occupation number basis and its associated Jordan-Wigner transformation, the occupation information is stored locally but the parity information is non-local, whereas in the parity basis method and its corresponding operator transformation, the parity information is stored locally but the occupation information is non-local.
          The Bravyi-Kitaev transformation is a middle ground, it balances the locality of occupation and parity information for improved simulation efficiency. In this scheme, qubits store the parity of a set of $2^x$ orbitals, where $x \geq 0$. A qubit of index $j$ always stores orbital $j$. For even values of $j$, this is the only orbital that it stores, but for odd values of $j$, it also stores a certain set of adjacent orbitals with index less than $j$. The map from the occupation number basis to the Bravyi-Kitaev basis is:
          \begin{equation}
              b_i = \sum_j {[\beta_n]_{ij} f_j},
          \end{equation}
          where $n$ is the number of orbitals, $\beta_n$ is an ($n \times n$) square matrix. See \cite{seeley2012bravyi} for a detailed explanation.
    \item \methodbravyikitaevsuperfast: A fast version of $bravyi\_kitaev()$, which can perform the Bravyi-Kitaev transformation at a faster speed \cite{setia2018bravyi}. Note that only Hermitian operators such as the following can be transformed:
          \begin{equation}
              C + \sum_{p,q} h_{p,q} a_p^{\dagger} a_q + \sum_{p,q,r,s} h_{p,q,r,s} a_p^{\dagger} a_q^{\dagger} a_r a_s,
          \end{equation}
          where $C$ is a constant.
    \item \methodreversedjordanwigner: Apply inverse transformation of Jordan-Wigner, which will transform $QubitOperator$ to $FermionOperator$.
    \item \methodternarytree: Apply the Ternary-Tree transformation. This function is based on \cite{jiang2020optimal}.
\end{itemize}
In the code below, we use the function $Transform()$ to transform $FermionOperator$ to $QubitOperator$.
\begin{lstlisting}
from mindquantum.core.operators import FermionOperator
from mindquantum.algorithm.nisq import Transform
op1 = FermionOperator('1^')
op_transform = Transform(op1)
op_transform.jordan_wigner()
# 0.5 [Z0 X1] +
# -0.5j [Z0 Y1]
op_transform.parity()
# 0.5 [Z0 X1] +
# -0.5j [Y1]
op_transform.bravyi_kitaev()
# 0.5 [Z0 X1] +
# -0.5j [Y1]
op2 = FermionOperator('1^', 'a')
Transform(op2).jordan_wigner()
# 0.5*a [Z0 X1] +
# -0.5*I*a [Z0 Y1]
\end{lstlisting}