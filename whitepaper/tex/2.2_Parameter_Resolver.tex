View demo code of this section: \democode{02}{2.2}

\subsubsection{Parameters in MindQuantum}
The parameterized quantum gates or circuits are key ingredients for quantum computing, especially for hybrid quantum-classical algorithms.
In \MindQuantum, we provide a Python Class \code{mindquantum.core.ParameterResolver} to efficiently manage these classical parameters.
Suppose we would like to initialize a parameterized gate, where the value of the parameter may change during an optimization process.
\ParameterResolver solves this problem by
denoting each parameter as a unique symbol, such as $\theta=0.1$, where $\theta$ is the symbol of the parameter and $0.1$ is the corresponding value.
Then we can use some symbols to denote the parameters instead of the real value when we write the code in \MindQuantum.
When we declare an instance of \ParameterResolver, we only need to give the symbols and the values as a Python dict, where the symbol is the key of the dict and the values as the value of the dict,

\begin{lstlisting}
import numpy as np
from mindquantum.core.parameterresolver import ParameterResolver

# Construct ParameterResolver with a dict
pr1 = ParameterResolver({'theta': np.pi})

# Construct ParameterResolver with a symbol 'a'
pr2 = ParameterResolver('a')

# This is equal to
pr3 = ParameterResolver({'a': 1.0})

# Declare a constant
pr4 = ParameterResolver(3)

# Arithmetic operator is also supported
pr5 = pr1 + pr2 * np.sqrt(2)
print(pr5.expression())
\end{lstlisting}

The expression of \code{pr5} will be displayed as $\sqrt{2}*a + \pi*\text{theta}$.

When parameterized circuits are simulated by \MindQuantum, the \ParameterResolver replaces the symbol in circuits as the corresponding real value declared in the \ParameterResolver.

In a hybrid quantum-classical algorithm, the parameters are usually optimized by some gradient descent methods such as SGD, ADAM, and BFGS. When we declare an instance of \ParameterResolver, by default, all parameters need to be differentiable.
However, we can explicitly state whether a parameter needs to be differentiated as follows,

\begin{lstlisting}
params.no_grad_part('theta')
\end{lstlisting}

Here, \code{params} is an instance of \ParameterResolver. The \code{no_grad_part('theta')} method is invoked to specify that the parameter named \code{theta} should be non-differentiable. This means that in any subsequent optimization steps or gradient calculations, the \code{theta} parameter will be excluded.

In a hybrid algorithm, parameterized quantum gates or circuits are usually divided into two parts, encoder, and ansatz. The encoder encodes the classical data into the quantum state. And the ansatz is an assumption about the form of an unknown function, and we can approximate the solution to the problem by optimizing it. By default, all parameters in \ParameterResolver are initialized as ansatz's parameters. We can convert these parameters between encoder's and ansatz's parameters in the following way

\begin{lstlisting}
#declare all parameters as encoder's parameters
params.as_encoder()

#declare all parameters as ansatz's parameters
params.as_ansatz()

#declare a given symbol as encoder's parameter
params.encoder_part('theta')

#declare a given symbol as ansatz's parameter
params.ansatz_part('theta')
\end{lstlisting}

We can also change the data type of parameters in a \ParameterResolver instance in the following way
\begin{lstlisting}
# reset the data type of params as mq.complex128
params.astype(mq.complex128)
\end{lstlisting}

\subsubsection{Parameter Generator}

Besides, \MindQuantum\ also provides a powerful tool to generate parameters quickly, \PRGenerator.
\begin{lstlisting}
from mindquantum.core.parameterresolver import PRGenerator

prg = PRGenerator(suffix='a')
a = prg.new()
b = prg.new()
print(a)
print(b)
print(len(prg.all_pr))
\end{lstlisting}
The output is:
\begin{lstlisting}
p0_a
p1_a
2
\end{lstlisting}
