The study of variational quantum algorithms has largely been focused on identifying the ground state of intricate many-body systems. In this context, the Variational Quantum Eigensolver (VQE) algorithm has emerged as a potent tool, designed to target the ground state of a many-body system by minimizing average energy. However, several critical phenomena in physics, including topological phases, necessitate knowledge of several low-energy eigenstates, not just the ground state. Therefore, the generalization of VQE to higher energy eigenstates is highly important.

The weighted SSVQE provides an alternative method to generate all the $k$ lowest energy eigenstates of a given Hamiltonian $H$~\cite{?}. This method utilizes a set of $k$ orthogonal initial states, denoted as $\{|\phi_{i}\rangle\}_{i=1}^{k}$ (where $\langle \phi_{i} | \phi_{j} \rangle = \delta_{ij}$), as the input of a single parameterized quantum circuit, described by the unitary operator $U(\vec{\theta})$. Given that the initial states are orthogonal, the outputs $U(\vec{\theta})| \phi_{j} \rangle$, generated by the same circuit, maintain orthogonality. In the weighted SSVQE, the objective is to minimize the cost function
\begin{equation}
    \mathrm{cost} = \sum_{i=1}^{k} w_{i} \langle \phi_{i}| U^{\dagger}(\vec{\theta}) H U(\vec{\theta}) | \phi_{i} \rangle
    \label{ssvqe_cost}
\end{equation}
where $w_1 > w_2 > \cdots > w_k$ are real positive numbers. Minimizing the cost function in Eq.~\eqref{ssvqe_cost} produces all the $k$ lowest energy eigenstates such that $|E_{i}\rangle = U(\vec{\theta}^{*})|\phi_{i}\rangle$.
A notable advantage of the weighted SSVQE is that it delivers all the $k$ lowest energy eigenstates through a single optimization process, without requiring any overlap of quantum states. However, the algorithm becomes more resource-demanding as the number of target eigenstates increases.

Symmetry is one of the most profound concepts in physics, especially in quantum mechanics. A majority of physical systems exhibit various types of symmetries that can be accurately described mathematically. The VQE algorithm can also significantly benefit from the integration of these symmetries. There are two ways to incorporate symmetries in the VQE algorithms: (i) designing the circuit to naturally generate the quantum states with the relevant symmetry~\cite{?}, and (ii) adding extra terms to the cost function to penalize the quantum states without the relevant symmetry~\cite{?}.


Leveraging the adaptability and comprehensive capabilities of MindQuantum, researchers are able to work with any optimization target by defining custom objective functions. Here, we present an example of implementing SSVQE through MindQuantum to accurately determine the four lowest state energies of the Heisenberg Hamiltonian, employing different symmetry incorporation strategies.


The full notebook and implementation is available at:
XXXXXXXXX

First, we need to construct the symmetry preserving ansatz~\cite{?}.
\begin{lstlisting}
def entangling_gate(parameter, qubits):
    circuit = Circuit()
    circuit += RZ(-np.pi / 2).on(qubits[1])
    circuit += CNOT.on(qubits[0], qubits[1])
    circuit += RZ({parameter: -2}).on(qubits[0])
    circuit += RZ(np.pi / 2).on(qubits[0])
    circuit += RY({parameter: 2}).on(qubits[1])
    circuit += RY(-np.pi / 2).on(qubits[1])
    circuit += CNOT.on(qubits[1], qubits[0])
    circuit += RY({parameter: -2}).on(qubits[1])
    circuit += RY(np.pi / 2).on(qubits[1])
    circuit += CNOT.on(qubits[0], qubits[1])
    circuit += RZ(np.pi / 2).on(qubits[0])
    return circuit

def ansatz(N, layers, local_rot=True):
    circuit = Circuit()
    params_index = 0
    for layer_index in range(layers):
        for i in range(2):
            for j in range(i, N - 1, 2):
                circuit += entangling_gate(str(params_index), [j, j + 1])
                params_index += 1
        if local_rot:
            for i in range(N):
                circuit += PhaseShift(params_index).on(i)
                params_index += 1
    return circuit
\end{lstlisting}

The SSVQE can then be implemented as a combination of several VQEs with distinct initialization circuits yet utilizing a shared parameter ansatz. One need to ensured that the resulting states post-initialization are orthogonal.
For each VQE, a unique measurement function can be defined to accomplish a variety of tasks.
Using the "get\_expectation\_with\_grad" function, one can easily obtain the expectation value and the corresponding gradient with respect to the trainable variables. Here, as an example, we demonstrate the code implementation for obtaining the second and the third lowest state energies of the Heisenberg Hamiltonian. In this particular instance,
we use a $S_z$-conserving ansatz, which preserves the $z$ component of the total spin, and the total spin operator is added to the cost function as a penalty term. The cost function is then modified into a form of
\begin{equation}
    \mathrm{cost} = \sum_{i=1}^{k} w_{i} \langle \phi_{i}| U^{\dagger}(\vec{\theta}) [H + (\hat{O} - c)^2] U(\vec{\theta}) | \phi_{i} \rangle,
    \label{ssvqe_cost_pen}
\end{equation}
where $c$ is a constant indicating the target subspace. Here, we do the expansion $(\hat{O} - c)^2 {=} \hat{O}^2 {-} c\hat{O} {+} c^2$. Together with the Hamiltonian, now we have three different measurement operators.

\begin{lstlisting}
class SSVQE:
    def __init__(self, n_qubits, init_circuits, pqc, ops):
        self.n_qubits = self.n_qubits
        self.circs = [circ + pqc for circ in init_circuits]
        self.sim = Simulator('mqvector', n_qubits)
        self.grad_ops = [self.sim.get_expectation_with_grad(ops, circ) for circ in circs]

    def __call__(self, inputs):
        cost = 0
        cost_grad = 0
        for i in range(len(self.grad_ops)):
            f, g = self.grad_ops[i](inputs)
            f1, f2, f3 = f[0, 0].real, f[0, 1].real, f[0, 2].real
            g1, g2, g3 = np.array(g[0, 0, :].real), np.array(g[0, 1, :].real), np.array(g[0, 2, :].real)
            cost += (f1 + f2 + f3) * (len(self.grad_ops) - i)
            cost_grad += (g1 + g2 + g3) * (len(self.grad_ops) - i)
        return cost, cost_grad
\end{lstlisting}

Now we need to set up the training function for the SSVQE. With all the module we predefined, the procedure is straightforward. The choice of the classical optimizer is flexible as well, here we choose the "L-BFGS-B" optimizer implemented in SciPy.

\begin{lstlisting}
def training(ssvqe, optimizer):
    initial_parameter = (np.random.rand(len(ssvqe.circs[0].params_name)) - .5) * np.pi
    result = optimizer.minimize(ssvqe, initial_parameter, jac=True, method='l-bfgs-b')
    return result
\end{lstlisting}

This implementation takes several minutes to finish training. One can track the results after each optimization step and generate a plot to compare the approximation results with the actual energies. In Fig.~\ref{}, we show the simulation results for the four lowest state energies of the Heisenberg Hamiltonian. It is clear to see that, incorporating SSVQE with the inherent symmetries, one can approximate both the ground and excited state energies precisely in a resource-efficient manner.
