# 基于迭代贝叶斯展开的可扩展测量误差缓解

姓名：王正荣 单位：天津工业大学 指导老师：华明

# 摘要

测量误差是制约量子计算可扩展的关键障碍之一，为抵消系统测量误差，除硬件层面的优化外，测量误差缓解后处理技术成为重要的解决方案。在本文中，作者采用向量化迭代贝叶斯展开算法，在6个9比特量子线路上进行了测量误差缓解。该算法具有运算速度快、收敛速度快、无负概率输出、内存占用低、训练数据量少及可扩展性好的特点。为进一步提升误差缓解效果，本文引入对角占优噪声矩阵对由测量校准电路所得的响应矩阵进行修正。此对角占优噪声矩阵不依赖量子电路中发生的具体噪声类型，结果表明，经修正的响应矩阵比未修正的响应矩阵展现出更优的误差缓解效果。在6个量子电路的测试中，修正后的响应矩阵的缓解平均总分达9548.9182分。

# 1 问题背景与描述

量子计算虽展现出超越经典计算的潜力，但量子噪声增至临界值时量子优越性会突然消失，它是实现大规模量子算法的主要障碍之一。在含噪中等规模量子器件时代，如何高效抑制噪声对测量结果的影响，成为量子计算领域的重要问题。在超导量子计算中，误差率的通常范围为：单量子门误差率一般在  $10^{- 4}$  到  $10^{- 3}$  之间[2]（0.01%到0.1%），双量子门误差率通常在  $10^{- 3}$  到  $10^{- 2}$  之间[2]（0.1%到1%），读出误差率一般在  $10^{- 2}$  到  $10^{- 1}$  之间[3,4]（1%到10%）。可见量子读出噪声是导致量子错误的重要来源之一。

# 赛题说明如下：

给定测量得到的量子态向量  $\vec{p}_{\mathrm{noisy}}$  （为了简化，下文描述中  $\vec{p}_{\mathrm{noisy}}$  被标记为  $\vec{p}$  ），设计算法求出矫正后的概率向量  $\vec{p}_{\mathrm{calibrated}}$ ，  $\vec{p}_{\mathrm{calibrated}}$  越接近理想分布  $\vec{p}_{\mathrm{ideal}}$  （在后文中被标记为  $\vec{\theta}$  ）得分越高，此外，根据训练算法所用数据量给予一定奖励分数，所用数据量越少则奖励分数越高。

1. 本赛题提供9比特“基本线路”和“目标线路”测量结果作为测试数据，每个线路都进行了50000次重复实验，即每个线路都有50000个独立的9比特测量结果。

2. 基本线路共512个，具体为将比特分别制备在  $\{^{\prime}000000000^{\prime}, ^{\prime}000000001^{\prime}, ^{\prime}000000010^{\prime}, \ldots , ^{\prime}111111111^{\prime}\}$  态后的测量结果，测量结果是比特排列顺序为  $[q8, q7, q6, q5, q4, q3, q2, q1, q0]$  的  $\{0, 1\}$  比特串。以  $\prime 000000010^{\prime}$  态为例，即在q1上作用X门，然后测量所有比特。基本线路的测量数据在文件 /samples/data/bitstrings_base.npz的 'arr_0' 中，是数据长度为  $\{512, 50000, 9\}$  的三维数组，分别对应量子态、重复次数和不同比特。

3. 目标线路共有6个，包含1个9比特GHZ态制备线路和5个随机线路，如图1所示。具体量子线路的路径为：'samples/circuit'，其中包含线路图和量子指令集两种表示形式以供参赛选手查看；测量结果在/samples/data/bitstrings_circuit_{i}.npz的'arr_0' 中，都是数据长度为  $\{50000, 9\}$  的二维数组，分别对应重复次数和不同比特，比特排列顺序为  $[q8, q7, q6, q5, q4, q3, q2, q1, q0]$ 。

4. 选手在作答时需通过样例代码 'answer.py' 中的 'get_data(state, qubits_number_list, random_seed) $]$  函数获取基本线路的测量数据，用于训练修正算法，该函数会对所用数据量进行计数，并影响最终得分，在“提交的答案”中绕过该函数获取“基本线路数据”视为作弊。

5. 选手可自由获取目标线路和测量数据用于训练修正算法，但需保证修正算法的通用性。当选手利用“目标线路的测量数据”进行预训练时，主办方会将该训练后的算法用“同一批次采集的其他量子线路测量数据”进行测试，当结果差异较大时，酌情进行减分或取消成绩。

![](https://cdn-mineru.openxlab.org.cn/result/2025-08-04/7fcf5152-7995-4b86-84f0-a47d7f3f192e/ad2149db583417f82e3d0ced1098bd89d38352efb554afbe1da9be3222a5ccf9.jpg)  
图1 (a)~(e)是目标线路中的5个随机量子线路，(f)是目标线路中的GHZ量子线路。

# 2 问题分析

在量子计算从理论走向实用的进程中，噪声干扰[1]是制约其发展的核心挑战之一。当前噪声中等规模量子设备的测量误差率通常在  $1\% - 10\%$  [3,9]之间，误差会导致量子态读取结果偏离真实值，严重影响量子算法的准确性与可靠性。例如，在量子化学模拟中，测量误差可能使分子能级计算结果偏差超过化学精度[10,11]；在量子纠错码[12- 15]中，错误的测量结果会直接破坏逻辑量子态的保护。因此，量子计算实用化需要高效的测量误差缓解技术。

测量误差可通过响应矩阵  $R$  描述——当真实量子态的概率分布为  $\vec{\theta}$  时，噪声会将其扭曲为观测分布  $\vec{p} = R\vec{\theta}$  。在逻辑门操作层面，通过优化控制参数等手段降低门操作物理执行中的噪声至关重要[16]。此外，研究人员提出了多种测量误差缓解方法，基于矩阵求逆的直接校正，通过  $R^{- 1}\vec{p}$  恢复真实分布，但该方法面临两个问题：一是矩阵求逆会引入负概率，违反物理意义；二是响应矩阵维度随量子比特数  $n$  呈  $2^{n} \times 2^{n}$  的指数增长，导致计算复杂度增加。采用误差外推和概率性误差消除方法[17- 19]，借助误差分布知识构造并优化计算结果估计量，以最大程度减少误差影响[20- 24]。另外，通过探索量子电路对称性，可利用后选择方法检测并消除部分电路误差[25- 26]。矩阵乘积算符[27]借助变分算法捕捉多量子比特间的噪声相关性，文献[28]提出，借助Clifford电路的高效模拟特性，无需预先知晓噪声模型，通过学习过程获取最优准概率分布。零噪声外推[29- 31]、子空间扩展[32]、连续误差缓解[33]也被用于测量误差缓解。

迭代贝叶斯展开算法[34,35]通过贝叶斯推理，为测量误差缓解提供了一种方法。通过交替更新后验分布，逐步逼近真实概率分布。迭代贝叶斯展开算法通过迭代优化，保证输出为合法概率分布，避免了负概率问题。通过子空间约简和稀疏矩阵分解[36]，将响应矩阵参数数目从指数级降至多项式级，使其适用于大规模量子比特规模的系统。向量化的迭代贝叶斯展开算法显著提升运算速度并减少内存占用。迭代贝叶斯算法需要响应矩阵  $R$  参与运算，响应矩阵  $R$  一般由  $2^{n}$  个校准电路大量重复测量而得到，因此响应矩阵  $R$  仅含有测量误差。然而在多量子比特系统的一定深度量子电路中，测量前可能出现去极化、退相位、比特翻转及幅度阻尼噪声错误[27]，导致响应矩阵  $R$  无法完整描述未知量子电路的噪声影响。

为此，在本文中，在向量化迭代贝叶斯算法的基础上，作者提出了对角占优噪声矩阵来修正由校准电路得到的响应矩阵。并在6个目标量子线路上测试了修正后的响应矩阵的误差缓解的表现，通过与没有修正过的响应矩阵相比，修正后的响应的缓解效

果优于没有修正的响应矩阵，而且对角占优噪声矩阵不依赖于电路中发生的具体噪声类型。

# 3 方案描述

# 3.1 迭代贝叶斯展开公式

大多数测量误差缓解方法假设：通过计算基测量量子态得到的理想概率分布  $\vec{\theta}$ ，会被响应矩阵  $R$  变换为含噪概率分布  $\vec{P}$ （因在错误基下测量导致失真），即

$$
\vec{p} = R\vec{\theta} \tag{1}
$$

公式（1）假定测量误差具有系统性、线性且不随时间变化。为获取响应矩阵，多数测量误差缓解技术进一步假设态制备误差可忽略。基于(1)的误差缓解方法一般需要两个步骤：1. 量子探测器层析[34,38]成像：通过该过程获取响应矩阵  $R$ 。其中，矩阵元素  $R_{ij}$  表示假设制备计算基元  $\left|b_{j}\right\rangle$  时，测量到位串  $b_{i}$  的条件概率。2. 概率分布校正：利用量子电路运行后测得的含噪概率分布  $\vec{p}$ ，通过响应矩阵求逆得到近似真实分布的  $\vec{\theta}$ ，即  $\vec{\theta} = R^{- 1}\vec{p}$ 。通过矩阵求逆缓解测量误差的方法会导致负概率，这在物理上是不合理的。这种方法得到只是准概率，它的元素可以大于1和产生负数，但元素之和等于1。已有许多方法被提出用于解决负概率问题，其中迭代贝叶斯展开便是其中一种。迭代贝叶斯展开[34,35]从响应矩阵  $R$ 、含噪分布  $\vec{P}$  和初始猜测  $\vec{\theta}^{0}$  出发，通过迭代更新概率分布，最终收敛于接近真实的概率分布  $\vec{\theta}$ 。迭代贝叶斯展开公式表达如下(公式的详细推导参见附录)：

$$
\theta_{j}^{k + 1} = \sum_{i = 1}^{2^{n}}p_{i}\cdot \frac{R_{ij}\theta_{j}^{k}}{\sum_{m}R_{im}\theta_{m}^{k}} \tag{2}
$$

其中， $p_i$  是含噪分布  $\vec{P}$  的第  $i$  个元素。为实现快速并行计算，我们将迭代贝叶斯公式（2）进行向量化重构。定义随机变量  $Z$  表示无测量误差的理想位串分布， $Z'$  表示含测量误差的位串分布。设  $c(z)$  为位串  $z_i'$  的观测计数， $S$  为总测量次数，那么含噪经验分布向量  $\vec{p} \in R^{2^n}$ ，其中  $p_i = \frac{c(z)}{s}$ ；第  $k$  次迭代的误差缓解分布  $\vec{\theta}^k \in \mathbb{R}^{2^n}$ ，其中；响应矩阵  $R \in R^{2^n \times 2^n}$ ，其中  $R_{ij} = P(Z_i' | Z_j)$ 。迭代贝叶斯展开公式(2)可等价表示为以下向量化形式[34]:

$$
\begin{array}{rl}\vec{\theta}^{k + 1} & = \sum_{i = 1}^{2^n}p_i\cdot \frac{R_i\odot\vec{\theta}^k}{R_i\vec{\theta}^k}\\ & = \left(\vec{p}^T\cdot \mathrm{diag}\left(\frac{1}{R\vec{\theta}^k}\right)\cdot R\cdot \mathrm{diag}\big(\vec{\theta}^k\big)\right)^T\\ & = \vec{\theta}^k\odot \left(R^T\big(\vec{p}\odot R\vec{\theta}^k\big)\right) \end{array} \tag{3}
$$

其中  $\odot$  和  $\oslash$  分别表示逐元素乘法和除法，T表示矩阵的转置操作，  $\mathrm{diag}(\vec{\theta}^k)$  表示以向量 $\vec{\theta}^k$  的元素为对角线元素构造的对角矩阵。该向量化形式支持高效并行计算，适用于大规模量子比特系统的误差缓解。

# 3.2 响应矩阵  $Re$  的构建

通常，对于  $n$  量子比特系统，构建响应矩阵  $R \in \mathbb{R}^{2^n \times 2^n}$  需执行  $2^n$  个校准电路[34,38]，每个电路需大量重复测量以拟合真实噪声分布。由于矩阵维度随  $n$  指数增长，量子探测器层析成像的实验次数呈指数级上升。为此，有人提出[34,36]：假设测量串扰具有  $k$  局部性，响应矩阵  $R$  可分解为  $n / k$  个独立的  $2^k \times 2^k$  子矩阵，如果  $k$  过于大，那么量子比特的串扰将被忽略。未缓解的概率分布具有稀疏性，且  $S$ （通常为500- 100,000次[34]）不随量子比特数指数增长。通过汉明距离筛选与观测位串邻近的矩阵元素  $R$ ，忽略远邻元素。在本文中，采用了9比特量子电路系统，量子比特排列顺序为  $[q8, q7, q6, q5, q4, q3, q2, q1, q0]$ ，从左到右为高位到低位。在减少实验次数的同时考虑不同量子比特间的关联串扰，把响应矩阵  $R$  分割为两部分，即

$$
R = R^{4,5,6,7,8} \otimes R^{0,1,2,3} \tag{4}
$$

其中， $R^{4,5,6,7,8}$  和  $R^{0,1,2,3}$  分别表示顺序为  $[q4,q3,q2,q1,q0]$  和  $[q8,q7,q6,q5]$  的量子比特响应矩阵。在提供的数据集中，每个校准电路测量了50000次，共  $2^{9}$  个校准电路，即数据集是  $[2^{9},50000,9]$  的三维数组。在本文中，我们分别选取  $[2^{5},4050,5]$  和  $[2^{4},4050,4]$  的数据集，即每个校准电路随机选取4050次的测量数据。

当我们利用式（4）所示的响应矩阵校准未知量子电路的读出位串时，隐含假设是仅存在读出噪声，即量子态在测量前未发生任何噪声错误。然而在实际量子电路中，量子态在测量前可能受到多种噪声的影响，包括去极化噪声、退相位噪声、比特翻转噪声和幅度阻尼噪声[27]。随着量子比特数目和电路深度的增加，这些噪声错误发生的概率提高。因此，实际测量结果不仅可能含有读出噪声，还可能包含了测量前各类噪声的叠加。所以，我们需要对式（4）进行修正，以更准确地表征真实的噪声情况。为此，引入对角占优噪声矩阵  $A\in R^{2^{9}\times 2^{9}}$  来描述测量前可能发生的噪声错误。假设A的对角元素  $A_{ii}$  是[0.49,1]上的均匀随机数，  $A$  的非对角元素  $A_{ij} = a^{- r\times r}$  其中  $i\neq j,a$  是  $A_{ij}$  的底数，  $r$  是衰减指数，控制了非对角元素的衰减速度，  $d = |i - j|$  描述了非对角元素与对角元素的距离。因此，修正响应矩阵  $Re$  表达式假设如下：

$$
\begin{array}{c}{Re = (\alpha_1R + \alpha_2R^2 +\alpha_3R^3) + (\beta_1A_{\eta_1} + \beta_2A_{\eta_1}^2 +\beta_3A_{\eta_1}^3) + (\gamma_1A_{\eta_2} + \gamma_2A_{\eta_2}^{90} + \gamma_3A_{\eta_2}^{91})}\\ {}\\ {= \phi_\alpha +\phi_\beta +\phi_\gamma \qquad (5)} \end{array} \tag{5}
$$

其中，  $\phi_{\alpha} = \alpha_{1}R + \alpha_{2}R^{2} + \alpha_{3}R^{3}$  ，  $\phi_{\beta} = \beta_{1}A_{\eta_{1}} + \beta_{2}A_{\eta_{1}}^{2} + \beta_{3}A_{\eta_{2}}^{3}$  ，  $\phi_{\gamma} = \gamma_{1}A_{\eta_{2}} + \gamma_{2}A_{\eta_{2}}^{2}+$ $\gamma_{3}A_{\eta_{2}}^{3}$  。  $R^{k}(k = \{1,2,3,90,91\})$  是响应矩阵  $R$  的  $k$  幂次，  $\alpha_{k}$  是其权重系数。  $A_{\eta_1}^k (A_{\eta_2}^k)$  是以 $\eta_{1}(\eta_{2})$  为非对角元素  $A_{ij}$  底数的噪声矩阵  $A$  的的  $k$  幂次。  $\beta_{k}(\gamma_{k})$  是其权重系数。  $\eta_{2} > \eta_{1}$  .  $r_{\beta}$  和  $r_{\gamma}$  分别是  $A_{\eta_1}^k$  和  $A_{\eta_2}^k$  的衰减指数，  $\phi^{\gamma}$  的非对角元素远远小于  $\phi^{\alpha}$  和  $\phi^{\alpha}$  的非对角元素。系数  $\alpha_{1}$  ，  $\alpha_{2}$  ，  $\alpha_{3}$  ，  $\beta_{1}$  ，  $\beta_{2}$  ，  $\beta_{3}$  ，  $\gamma_{1}$  ，  $\gamma_{2}$  ，  $\gamma_{3}$  可通过将  $Re$  代入迭代贝叶斯展开公式（3）并根据迭代收敛结果确定，或通过梯度下降算法[37]确定。在（5）式中，  $\phi^{\beta}$  和  $\phi^{\gamma}$  并不依赖于量子电路发生的噪声类型，因此是噪声独立的。取以下参数：在  $\phi^{\alpha}$  中，  $\alpha_{1} = \alpha_{2} =$

0,  $\alpha_{3} = 1$  。在  $\phi^{\beta}$  中,  $\beta_{1} = 1.05$  ,  $\beta_{2} = 0$  ,  $\beta_{3} = 0.758888$  ,  $\eta_{1} = 2.69$  ,  $r_{\beta} = 5.4$  。在  $\phi^{\gamma}$  中,  $\gamma_{1} = 0$  ,  $\gamma_{2} = 0.4$  ,  $\gamma_{3} = 1.2$  ,  $\eta_{2} = r_{\gamma} = 10$  。在这些参数下,修正响应矩阵  $Re$  如图2所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-08-04/7fcf5152-7995-4b86-84f0-a47d7f3f192e/0de707e998236fcf02875c3314e65dd25a14815744c138cbde9d6f2728c41eb8.jpg)  
图2 修正响应矩阵  $Re$  颜色映射图。坐标范围是  $0 \sim 511$  ，分别表示量子态范围  $|00000000\rangle \sim |111111111\rangle$  。选取  $[2^{5}, 4050, 5]$  和  $[2^{4}, 4050, 4]$  的数据集，每个校准电路随机选取 4050 次的测量结果。

# 3.3 评分公式

总分  $=$  基础分  $+$  奖励分，基础分表达如下：

$$
score = 10000 \times \left(1 - \frac{1}{2} \sum_{i = 1}^{k} |P_{i} - Q_{i}|\right) \tag{6}
$$

其中， $P_{i}$  是迭代贝叶斯展开算法得到的目标向量  $\vec{p}_{a}$  中的元素， $Q_{i}$  是理想分布  $\vec{p}_{ideal}$  中的元素。 $TVD = \frac{1}{2}\sum_{i = 1}^{k}|P_{i} - Q_{i}|$  的值在0到1之间，0表示两个分布完全相同，1表示完全不重叠。奖励分表达如下：

$$
\alpha = 0.005\times (50000\times 512\times 9 - \mathrm{train\_sample\_num}) / (50000\times 512\times 9) \tag{7}
$$

其中，‘train_sample_num’为校准量子电路测量结果的数据量，每个量子态、每个比特、每个测量结果的数据量记为1。在本文中，train_sample_num =  $4050\times (32\times 5 + 16\times 4) = 907200$  。因此，总分表达式如下：

$$
finalscore = 10000\times \left(1 - \frac{1}{2}\sum_{i = 1}^{k}|P_{i} - Q_{i}| + \alpha\right) \tag{8}
$$

# 3.4 算法实现过程

在这项研究中，提供了9比特的5个随机量子线路和1个GHZ量子线路共6个目标量子线路用于测量误差缓解，每个线路都测量50000次，测量数据都为[50000,9]的二维数组。

初始化：从  $[2^{9},50000,9]$  的三维数组中选取  $[2^{5},4050,5]$  和  $[2^{4},4050,4]$  的数据集，构建响应矩阵  $\mathrm{R} = \mathrm{R}^{4,5,6,7,8}\otimes \mathrm{R}^{0,1,2,3}$ ，再根据公式（5）进一步得到修正响应矩阵  $Re$  。从6个目标线路的测量数据（6个二维数组[50000,9]）中计算用于误差缓解的含噪向量  $\vec{p}_{j}^{i}$ ，其中， $i = 1,2,3,4,5,6$  表示第  $i$  个量子线路， $j = 0,1\dots 511$  表示j个分量。给定初始猜测均匀分布向量  $\vec{\theta}_{i}^{6}$  。设置迭代精度阈值precision_threshold  $= \frac{1}{2}\sum_{i = 1}^{k}|\theta_{i}^{k + 1} - \theta_{i}^{k}|$  和最大迭代次数max_iterations。

# 3.4.1 初始化代码实现过程

# 3.4.1.1 获取测量数据

对应代码块：函数“get_data”随机获取测量的数据，随机数种子“random_seed=2025”。

# 3.4.1.2 构建响应矩阵R

对应代码块：函数“build_adjacent_response_matrix”的功能为构建任意相邻量子比特的响应矩阵，随机获取的量子线路测量样本数量“sample_num = 4050”，因此代码块

$\mathbf{b}\mathbf{1} = [\mathbf{0},\mathbf{1},2,3]$ 
$\mathbf{b}2 = [4,5,6,7,8]$ 
$\mathbf{R1} =$  build_adjacent_response_matrix(b1)  
$\mathbf{R2} =$  build_adjacent_response_matrix(b2)

$\mathbf{R} = \mathbf{np}.\mathbf{kron}(\mathbf{R2},\mathbf{R1})$  ”实现了响应矩阵R的构建，其中b1和b2分别是态

$|q8,q7,q6,q5\rangle$  和|q4,q3,q2,q1,q0)的比特序号，“np.kron(R2,R1)”是运算$R2\otimes R1$。

# 3.4.1.3 构建修正响应矩阵Re

对角占优噪声矩阵A由函数“diagonally\_dominant\_noise\_matrix”输出，所以修正响应矩阵Re由下面代码生成。

对应代码块：“RR  $=$  (np.linalg.matrix_power(R,3))

A = diagonally\_dominant\_noise\_matrix(RR.shape[0], diag_low=0.49,

diag_high=1.0, decay_rate = 5.4, seed =

1000, bn = 2.69)

AA = diagonally\_dominant\_noise\_matrix(RR.shape[0], diag_low=0.49,

diag_high=1.0, decay_rate = 10, seed = 1000,

bn = 10)

A1 = (np.linalg.matrix_power(A, 3))

AA1 = (np.linalg.matrix_power(AA, 90))

AA2 = (np.linalg.matrix_power(AA, 91))

$$
\mathbf{RA} = \mathbf{RR} + \mathbf{A} * 1.05 + \mathbf{A1} * 0.758888 + \mathbf{AA2} * 1.2 + \mathbf{AA1} * 0.4
$$

$$
\mathrm{col\_sums} = \mathrm{RA.sum(axi s = 0)}
$$

$\mathbf{Re} = \mathbf{np.where(col\_sums} = =0,0,\mathbf{RA / col\_sums})$  ”，其中“np.linalg.ma-

trix_power”表示矩阵幂运算，“col\_sums = RA.sum(axis=0)”表示对矩阵RA的列求和得到向量“col\_sums”，“np.where”表示归一化操作并且当列和为0时对应的列用0填充避免除以0。

# 3.4.1.4 含噪向量  $\vec{P_j}$  和理想向量  $\vec{p}_{ideal}$  的获取

由评分程序文件“run.py”给出。

对应代码块：“IDEAL_PROB_LIST  $=$  []

MEASURE_PROB_LIST  $=$  [] 
for circuit_idx in [1,2,5,6,8,'ghz']

 #读取线路数据

打开文件并读取内容with open(f./samples/circuit/circuit_{circuit_idx}.txt', 'r') as file:qasm_content = file.read()

 #利用mindquantum计算理想结果

circuit  $=$  Circuit().from_openqasm(qasm_content)sim  $=$  Simulator('mqvector',9) #声明一个9比特的qmvector模拟器sim.apply_circuit(circuit)ideal\_prob  $=$  np.abs(sim.get_qs()) \*\* 2

IDEAL_PROB_LIST.append(ideal_prob)

#读取测量结果

bitstring_arr  $=$  np.load(f./samples/data/bitstrings_circuit_{circuit_idx}.npz')['arr_0']

prob_dict  $=$  bitstring_arr2vec(bitstring_arr,q_num=0)

#转换为arr

measure\_prob  $=$  dict2vec(nqubits=9, res_dict=prob_dict, reverse=False)

MEASURE_PROB_LIST.append(measure_prob)”，此代码块运行结束后，

含噪向量  $\vec{P_j}$  和理想向量  $\vec{p}_{ideal}$  分别存储在列表“MEASURE_PROB_LIST”和

“IDEAL_PROB_LIST”。中。

# 3.4.2 向量化迭代贝叶斯展开算法流程及其对应代码

当大于迭代精度阈值“precision_threshold”和小于最大迭代次数“max_iterations”时执行a、b、c步骤，不满足其中一个条件时退出运行。对应代码块：“while True:

检查停止条件条件1：精度达标precision  $=$  np.sum(np.abs(theta - t_prev))/2if precision  $<$  precision_threshold:print(f"精度达标，提前终止于迭代{iteration  $+1$  ")break#条件2：超过最大迭代次数if iteration  $> =$  max_iterations- 1：#注意迭代从0开始计数print(f"达到最大迭代次数{max_iterations}")breakreturn theta"。

# a.计算  $R\vec{\theta}^k$

对应代码块：“denominator  $=$  np.dot(Re,theta)”，“np.dot”表示矩阵和向量相乘。

b.计算  $\vec{p}\oslash R\vec{\theta}^k$

对应代码块：“np.clip(denominator,eps,None,out=denominator)ratio  $= \mathfrak{p}$  /denominator”，其中“np.clip”的作用将向量“denominator”中的元素限制在“eps”到正无穷大的范围内，防止除零操作。

c.计算  $\vec{\theta}^k\odot \left(R^T (\vec{p}\odot R\vec{\theta}^k)\right)$

对应代码块：“  $\mathbf{R} = \mathbf{Re}.\mathbf{T}$

theta  $=$  theta  $\mathbf{\Psi} =$  np.dot(R,ratio)”。其中，“np.dot(R,ratio)”计算  $R^T (\vec{p}\oslash R\vec{\theta}^k)$

完整向量化迭代贝叶斯展开函数代码如下：

def IBU(p: np.ndarray, theta0: np.ndarray, Re: np.ndarray,       precision_threshold: float, max_iterations: int) - > np.ndarray:
"""

Iterative Bayesian Unfolding 方法，支持最大迭代次数和精度阈值双停止条件。

#Args:

p: 测量概率分布 (shape:  $[2^{\wedge}k]$ )theta0: 初始猜测的真实分布 (shape:  $[2^{\wedge}k]$ )Re: 修正响应矩阵 (shape:  $[2^{\wedge}k,2^{\wedge}k]$ )precision_threshold: 精度阈值，当迭代变化小于该值时提前终止max_iterations: 最大允许迭代次数

Returns:theta: 修正后的真实分布 (shape:  $[2^{\wedge}k]$ )
"""

$\mathbf{R} = \mathbf{Re}.\mathbf{T}$  theta  $=$  theta0. copy().astype(np.float64)  $\mathbf{eps} = 1\mathbf{e} - 12$  t_prev  $=$  theta.copy() iteration  $= 0$

while True:

IBU迭代步骤 denominator  $=$  np.dlot(Re,theta) np.clip(denominator,eps,None,out  $\equiv$  denominator) ratio  $= \mathbf{p}$  /denominator theta  $=$  theta \* np.dlot(R,ratio)

归一化 t_sum  $=$  theta.sum() if t_sum  $>0$  theta  $/ = t_{- }$  sum

检查停止条件

检查停止条件# 条件1: 精度达标precision  $=$  np.sum(np.abs(theta - t_prev)) / 2if precision < precision_threshold:    print(f"精度达标，提前终止于迭代 {iteration + 1}")    break

条件2: 超过最大迭代次数if iteration  $> =$  max_iterations - 1: # 注意迭代从0开始计数print(f"达到最大迭代次数 {max_iterations}")break

更新状态t_prev = theta.copy()iteration += 1

print("总迭代次数：{iteration + 1}")return theta

# 3.4.3 缓解含噪向量

6个目标量子线路的含噪向量缓解后的结果由函数“correct”输出。

# 对应代码块：

对应代码块：def correct(measure_prob_list):    """    将六个量子线路的测量结果measure_prob_list分别修正并返回，    请参赛选手保持本函数的输入measure_prob_list和输出corrected_prob_list格式不变；

输入值measure_prob_list为包含6个量子线路“原始”测量概率的列表，返回值corrected_prob_list为包含6个量子线路“修正后”测量概率的列表，

global TRAIN_SAMPLE_NUM

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

获取“态制备- 测量”结果，并建立修正矩阵 
$\mathbf{b1} = [0,1,2,3]$ 
$\mathbf{b2} = [4,5,6,7,8]$ 
$\mathbf{R1} =$build_adjacent_response_matrix(b1) 
$\mathbf{R2} =$  build_adjacent_response_matrix(b2) 
$\mathbf{R} =$  np.kron(R2,R1)

$\mathbf{RR} =$  (np.linalg.matrix_power(R,3)) 
$\mathbf{A} =$  diagonallydominant noise_matrix(RR.shape[0],diag_low=0.49,diag_high=1.0,decay_rate  $= 5.4$  ,seed  $= 1000$ $\mathbf{bn} = 2.69$  AA  $=$  diagonallydominant noise_matrix(RR.shape[0],diag_low=0.49,diag_high=1.0,decay_rate  $= 10$  ,seed  $= 1000$ $\mathbf{bn} = 10$

$\mathbf{A1} =$  (np.linalg.matrix_power(A,3)) 
 $\mathbf{AA1} =$  (np.linalg.matrix_power(AA,90))  
 $\mathbf{AA2} =$  (np.linalg.matrix_power(AA,91)) 
  $\mathbf{RA} = \mathbf{RR} + \mathbf{A}^{*}1.05 + \mathbf{A1}^{*}0.758888 + \mathbf{AA2}^{*}1.2 + \mathbf{AA1}^{*}0.4$ 
   col_sums  $= \mathrm{RA}$  .sum(axis  $= 0$ $\mathbf{Re} = \mathbf{np}$  .where(col_sums  $= = 0$  ,0,RA/col_sums）#使用np.where避免除以零的情况 #将六个量子线路的测量结果measure_prob_list分别修正并返回

vec_size  $= 2$  \*\*9 max_iterations  $= 8000$  precision_threshold  $= 10^{\ast \ast}(- 20)$  corrected_prob_list  $=$  || #for measure_prob in measure_prob_list: for_idx,measure_prob in cemenerate(measure_prob_list): print(fprob idx  $=$  [,idx]) _prob  $=$  IBU(measure_prob, np.ones(vec_size) / vec_size, Re, precision_threshold, max iterations) corrected_prob_list.append(_prob)

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

return corrected_prob_list, TRAIN_SAMPLE_NUM

# 4 结果与分析

在向量化的迭代贝叶斯展开公式（3）中，仅需4步运算即可同步更新待缓解向量的所有  $2^{n}$  个分量（  $n$  为量子比特数）。该方法仅需存储响应矩阵、更新向量和待缓解向量，无需额外内存存储中间数据。此外，公式（3）还具有无负概率产生、构建响应矩阵  $R$  所需数据量小的特点，使其适用于大规模量子比特系统，并可在多项式时间内高效求解。特别地，构建对角占优噪声矩阵  $A$  时无需预先知晓测量前量子电路发生的具体噪声类型。表1展示了响应矩阵  $R$  逐项修正后6个目标量子线路平均总分afinal score的变化。

表1响应矩阵逐渐考虑噪声项后平均总分afinalscore的变化，未缓解的afinalscore  $=$  9313.5539。  

<table><tr><td>修正响应矩阵Re表达式</td><td>afinal score</td></tr><tr><td>R</td><td>9510.1354</td></tr><tr><td>R²</td><td>9525.7596</td></tr><tr><td>R³</td><td>9467.6914</td></tr><tr><td>R⁴</td><td>9394.1089</td></tr><tr><td>R+R²+R³</td><td>9527.1080</td></tr><tr><td>R+R²+R³+R⁴</td><td>9502.2340</td></tr></table>

<table><tr><td>R+R²+R³+1.05Aη1</td><td>9538.9596</td></tr><tr><td>R³+1.05Aη1</td><td>9542.7805</td></tr><tr><td>R³+1.05Aη1+0.758888Aη1</td><td>9547.5510</td></tr><tr><td>R³+1.05Aη1+0.758888Aη1+0.4Aη0</td><td>9548.0179</td></tr><tr><td>R³+1.05Aη1+0.758888Aη1+0.4Aη0+1.2Aη1</td><td>9548.9182</td></tr></table>

在表1中， $A_{\eta_1}$  和  $A_{\eta_2}^{90}$  中的参数设置和图2一致。每一个平均总分afinal score都迭代了8000次而得到，由运行程序可得到：在  $Re = R^3 + 1.05A_{\eta_1} + 0.758888A_{\eta_1}^3 + 0.4A_{\eta_2}^{90} + 1.2A_{\eta_2}^{91}$  下，当迭代到第10次时平均总分afinal score = 9545.4170，而当迭代了8000次时平均总分afinal score = 9548.9182，可见，向量化迭代贝叶斯展开算法快速收敛于局部最大值。当  $Re$  从  $R \rightarrow R^2$ ，afinal score 从  $9510.1354 \rightarrow 9525.7596$ ，这是因为响应矩阵  $R$  的二次幂在一定程度上弥补了未测量之前所发生的噪声错误，即  $R^2$  比  $R$  包含更多的噪声更符合待缓解的量子线路所发生的噪声错误。在  $R^3$  和  $R^4$  下，afinal score 下降，表明  $R$  的三次和四次幂所含噪声过多。因此，进一步引入对角占优噪声矩阵  $A$  来修正由测量校准电路得到的响应矩阵，从表1的第8行到12行可以看到， $A$  的引入提高了afinal score，与  $A$  有关的项可考虑作为微扰项而添加到修正响应矩阵中。值得注意的是，从表1的第9行到第12行中看出，修正响应矩阵是以  $R^3$  作为主项而被  $A$  的相关项调制的。

# 5 参考文献

[1] Sun W, Wei F, Shao Y, et al. Sudden death of quantum advantage in correlation generations. [J]. Science Advances, 2024, 10(47): eadr5002. [2] R B, J K, A M, et al. Superconducting quantum circuits at the surface code threshold for fault tolerance[J]. Nature, 2014, 508(7497): 500- 3. [3] Nachman B, Urbanek M, Jong D A W, et al. Unfolding quantum computer readout noise[J]. npj Quantum Information, 2020, 6(1): 84- 84. [4] Guo Y, Yang S. Quantum error mitigation via matrix product operators[J]. PRX Quantum, 202- 2, 3(4): 040313.

[5] Chen Y, Farahzad M, Yoo S, et al. Detector tomography on IBM quantum computers and mitigation of an imperfect measurement[J]. Physical Review A, 2019, 100(5): 052315. [6] Chow J M, DiCarlo L, Gambetta J M, et al. Detecting highly entangled states with a joint qubit readout[J]. Physical Review A, 2010, 81(6): 062325. [7] Ryan C A, Johnson B R, Gambetta J M, et al. Tomography via correlation of noisy measurement records[J]. Physical Review A, 2015, 91(2): 022118. [8] Merkel S T, Gambetta J M, Smolin J A, et al. Self- consistent quantum process tomography[J]. Physical Review A, 2013, 87(6): 062119. [9] Chow J M, Gambetta J M, Corcoles A D, et al. Universal Quantum Gate Set Approaching Fault- Tolerant Thresholds with Superconducting Qubits[J]. Physical Review Letters, 2012, 109(6): 060501. [10] Li Y, Benjamin S C. Efficient variational quantum simulator incorporating active error minimization[J]. Physical Review X, 2017, 7(2): 021050. [11] Yuan X, Endo S, Zhao Q, et al. Theory of variational quantum simulation[J]. Quantum, 2019, 3191- 191. [12] Gottesman D. An introduction to quantum error correction[C]. Proceedings of Symposia in Applied Mathematics. 2002, 58: 221- 236. [13] Devitt S J, Munro W J, Nemoto K. Quantum error correction for beginners[J]. Reports on Progress in Physics, 2013, 76(7): 076001. [14] Terhal B M. Quantum error correction for quantum memories[J]. Reviews of Modern Physics, 2015, 87(2): 307- 346. [15] Nielsen M A, Chuang I L. Quantum computation and quantum information[M]. Cambridge university press, 2010. [16] Motzoi F, Gambetta J M, Rebentrost P, et al. Simple pulses for elimination of leakage in weakly nonlinear qubits[J]. Physical Review Letters, 2009, 103(11): 110501. [17] Li Y, Benjamin S C. Efficient variational quantum simulator incorporating active error minimization[J]. Physical Review X, 2017, 7(2): 021050. [18] Temme K, Bravyi S, Gambetta J M. Error mitigation for short- depth quantum circuits[J]. Physical Review Letters, 2017, 119(18): 180509. [19] Endo S, Benjamin S C, Li Y. Practical quantum error mitigation for near- future application[J].

Physical Review X, 2018, 8(3): 031027.

[20] Song C, Cui J, Wang H, et al. Quantum computation with universal error mitigation on a superconducting quantum processor[J]. Science Advances, 2019, 5(9): eaaw5686.

[21] Zhang S, Lu Y, Zhang K, et al. Error- mitigated quantum gates exceeding physical fidelities in a trapped- ion system[J]. Nature Communications, 2020, 11(1): 587.

[22] Kwon H, Bae J. A hybrid quantum- classical approach to mitigating measurement errors in quantum algorithms[J]. IEEE Transactions on Computers, 2020, 70(9): 1401- 1411.

[23] Chen Y, Farahzad M, Yoo S, et al. Detector tomography on IBM quantum computers and mitigation of an imperfect measurement[J]. Physical Review A, 2019, 100(5): 052315.

[24] Geller M R, Sun M. Toward efficient correction of multiqubit measurement errors: Pair correlation method[J]. Quantum Science and Technology, 2021, 6(2): 025009.

[25] McArdle S, Yuan X, Benjamin S. Error- mitigated digital quantum simulation[J]. Physical Review Letters, 2019, 122(18): 180501.

[26] Bonet- Monroig X, Sagastizabal R, Singh M, et al. Low- cost error mitigation by symmetry verification[J]. Physical Review A, 2018, 98(6): 062339.

[27] Guo Y, Yang S. Quantum error mitigation via matrix product operators[J]. PRX Quantum, 20- 22, 3(4): 040313.

[28] Strikis A, Qin D, Chen Y, et al. Learning- based quantum error mitigation[J]. PRX Quantum, 2021, 2(4): 040330.

[29] Kandala A, Temme K, Corcoles A D, et al. Error mitigation extends the computational reach of a noisy quantum processor[J]. Nature, 2019, 567(7749): 491- 495.

[30] Dumitrescu E F, McCaskey A J, Hagen G, et al. Cloud quantum computing of an atomic nucleus[J]. Physical review letters, 2018, 120(21): 210501.

[31] He A, Nachman B, de Jong W A, et al. Resource efficient zero noise extrapolation with identity insertions[J]. arXiv preprint arXiv:2003.04941, 2020.

[32] McClean J R, Kimchi- Schwartz M E, Carter J, et al. Hybrid quantum- classical hierarchy for mitigation of decoherence and determination of excited states[J]. Physical Review A, 2017, 95(4): 042308.

[33] Sun J, Yuan X, Tsunoda T, et al. Practical quantum error mitigation for analog quantum simulation[J]. arXiv preprint ArXiv:2001.04891.

[34] Pokharel B, Srinivasan S, Quiroz G, et al. Scalable measurement error mitigation via iterative bayesian unfolding[J]. Physical Review Research, 2024, 6(1): 013187.

[35] Nachman B, Urbanek M, de Jong W A, et al. Unfolding quantum computer readout noise[J]. npj Quantum Information, 2020, 6(1): 84.

[36] Nation P D, Kang H, Sundaresan N, et al. Scalable mitigation of measurement errors on quantum computers[J]. PRX Quantum, 2021, 2(4): 040326.

[37] Bishop C M, Nasrabadi N M. Pattern recognition and machine learning[M]. New York: springer, 2006.

[38] Maciejewski F B, Zimborás Z, Oszmaniec M. Mitigation of readout noise in near- term quantum devices by classical post- processing based on detector tomography[J]. Quantum, 2020, 4: 2- 57.

# 附录：迭代贝叶斯展开公式（2）的推导

假设所有测量在  $2^{n}$  个基下进行，  $n$  为量子比特的数目。设  $z_{j}\in Z$  为表示第  $j$  个测量基，  $P(z_{j})$  表示  $z_{j}$  的理想概率。由于测量误差，实际测得的位串分布与理论分布不同。记实际测量分布的位串为  $Z^{\prime}$  ，其分布为  $P(Z^{\prime})$  。现有  $S$  次测量的数据集  $Z^{\prime} =$ $\{z_1^{\prime},z_2^{\prime},z_3^{\prime}\ldots z_s^{\prime}\}$  为  $P(Z^{\prime})$  的独立相同分布样本。我们使用最大似然法来推导贝叶斯展开公式，因此，因此把理想概率分布  $P(z_{j})$  参数化，  $P(z_{j})$  记作  $P_{\theta}(z_{j})$  ，  $P_{\theta}(z_{j})$  为维度为  $2^{n}$  的向量，它的分量  $\theta_{j}$  满足  $\begin{array}{r}\sum_{j = 1}^{2^n}\vec{\theta}_j = 1 \end{array}$  。  $\begin{array}{r}P(z_i^{\prime}) = \sum_{j}^{2^n}P(z_i^{\prime}|z_j)P_{\theta}(z_j) \end{array}$  。  $S$  次测量的位串的联合概率的似然函数表达为：

$$
P(Z^{\prime};\vec{\theta}) = \prod_{i = 1}^{S}P(z_{i}^{\prime}) = \prod_{i = 1}^{S}\sum_{j = 1}^{2^{n}}P(z_{i}^{\prime}|z_{j})P_{\theta}(z_{j}) \tag{A1}
$$

我们需要寻找使  $P(Z^{\prime};\vec{\theta})$  最大的参数  $\vec{\theta}$  ，为了方便将  $P(Z^{\prime};\vec{\theta})$  取对数，(A1)变为

$$
l(Z';\vec{\theta}) = \ln P(Z';\vec{\theta}) = \sum_{i = 1}^{S}\ln \left(\sum_{j = 1}^{2^n}P(z'_i|z_j)P_\theta (z_j)\right) \tag{A2}
$$

已知参数  $\vec{\theta}$  时，可直接计算观测比特串与真实比特串（即无测量误差时的理想比特串）的联合概率：  $P(z'_i,z_j;\vec{\theta}) = P(z'_i|z_j)P_\theta (z_j)$  反之，若已知任意观测与潜在比特串的联合概率  $P(z'_i,z_j;\vec{\theta})$ ，可通过反解上述方程推断参数  $\vec{\theta}$  。期望最大化算法将此逻辑转化为迭代优化过程，交替执行：1. 基于当前参数  $\vec{\theta}^k$ ，计算观测与潜在比特串的条件期望联合对数似然；2. 求解参数  $\vec{\theta}^{k + 1}$  使该期望对数似然最大化。利用Jensen不等式，式(A2)可转化为：

$$
\begin{array}{rl} & {l(\vec{\theta};Z^{\prime}) = \sum_{i = 1}^{S}\ln \left(\sum_{j = 1}^{2^{n}}P(z_{i}^{\prime}|z_{j})P_{\theta}(z_{j})\cdot \frac{P_{\theta^{k}}(z_{j}|z_{i}^{\prime})}{P_{\theta^{k}}(z_{j}|z_{i}^{\prime})}\right)}\\ & {\qquad = \sum_{i = 1}^{S}\ln \left(\sum_{j = 1}^{2^{n}}P_{\theta^{k}}(z_{j}|z_{i}^{\prime})\cdot \frac{P(z_{i}^{\prime}|z_{j})P_{\theta}(z_{j})}{P_{\theta^{k}}(z_{j}|z_{i}^{\prime})}\right)}\\ & {\qquad \geq \sum_{i = 1}^{S}\sum_{j = 1}^{2^{n}}P_{\theta^{k}}(z_{j}|z_{i}^{\prime})\ln \left(\frac{P(z_{i}^{\prime},z_{j};\vec{\theta})}{P_{\theta^{k}}(z_{j}|z_{i}^{\prime})}\right)}\\ & {\qquad = l(\vec{\theta} |\vec{\theta};Z^{\prime})} \end{array} \tag{A3}
$$

其中  $P(z_{i}^{\prime},z_{j};\vec{\theta}) = P(z_{i}^{\prime}|z_{j})P_{\theta}(z_{j})$ ，我们可以通过在给定时间步长更新参数  $\vec{\theta}^k$  来局部最大化对数似然的下界  $l(\vec{\theta} |\vec{\theta};Z^{\prime})$ ，即：

$$
\begin{array}{rl} & {\vec{\theta}^{k + 1} = arg\underset {\vec{\theta}^k}{max}\sum_{i = 1}^{S}\sum_{j = 1}^{2^n}P_{\theta^k}\left(z_j|z_i'\right)ln\left(\frac{P\left(z_i',z_j;\vec{\theta}\right)}{P_{\theta^k}\left(z_j|z_i'\right)}\right)}\\ & {\quad = arg\underset {\vec{\theta}^k}{max}\sum_{i = 1}^{S}\sum_{j = 1}^{2^n}P_{\theta^k}\left(z_j|z_i'\right)P\left(z_i',z_j;\vec{\theta}\right)} \end{array} \tag{A4}
$$

其中，arg max  $f(\vec{\theta}^k)$  表示使  $f(\vec{\theta}^k)$  达到最大的参数向量  $\vec{\theta}^k$  。引入拉格朗日乘数约束  $\lambda$ ，

求偏导可得到下式：

$$
\begin{array}{rl} & {\frac{\partial}{\partial\theta_j}\left(\sum_{i = 1}^S\sum_{j = 1}^{2^n}P_{\theta^k}(z_j|z_i')\ln P(z_i',z_{j};\vec{\theta}) + \lambda \left(1 - \sum_{j = 1}^{2^n}\theta_{j'}\right)\right)}\\ & {= \frac{\partial}{\partial\theta_j}\left(\sum_{i = 1}^S\sum_{j = 1}^{2^n}P_{\theta^k}(z_j|z_i')\ln P_\theta (z_{j'} + \lambda \left(1 - \sum_{j = 1}^{2^n}\theta_{j'}\right)\right)}\\ & {= \frac{\partial}{\partial\theta_j}\left(\sum_{i = 1}^S\sum_{j = 1}^{2^n}P_{\theta^k}(z_{j}|z_i')\ln \theta_{j'} + \lambda \left(1 - \sum_{j = 1}^{2^n}\theta_{j'}\right)\right)}\\ & {= \left(\sum_{i = 1}^S P_{\theta^k}(z_j|z_i')\right)\frac{1}{\theta_j} -\lambda .} \end{array} \tag{A5}
$$

将其设为零，我们得到  $\theta_{j} = \frac{1}{\lambda}\big(\sum_{i = 1}^{S}P_{\theta^{k}}\left(z_{j}|z^{\prime}_{i}\right)\big)$  ，又因为  $\Sigma_{j}\vec{\theta}_{j} = 1$  ，所以 $\begin{array}{r}\sum_{j}\frac{1}{\lambda}\big(\sum_{i = 1}^{S}P_{\theta^{k}}\left(z_{j}|z^{\prime}_{i}\right)\big) = 1 \end{array}$  ，因此  $\begin{array}{r}\lambda = \sum_{i = 1}^{S}\sum_{j}P_{\theta^{k}}(z_{j}|z^{\prime}_{i}) = \sum_{i = 1}^{S}1 = S \end{array}$  。将其代回，我们得到在给定猜测  $\vec{\theta}^{k}$  下局部最大化对数似然的  $\vec{\theta}$  中每个元素  $\theta_{j}$  的更新规则：

$$
\theta_{j}^{k + 1} = \frac{1}{S}\sum_{i = 1}^{S}P_{\theta^{k}}(z_{j}|z^{\prime}_{i}) \tag{A6}
$$

根据贝叶斯规则，我们有  $P_{\theta^{k}}(z_{j}|z^{\prime}_{i}) = \frac{P(z^{\prime}_{i}|z_{j})P_{\theta^{k}}(z_{j})}{\sum_{m}P(z^{\prime}_{i}|z_{m})P_{\theta^{k}}(z_{m})}$  无需对数据集中的每个比特串求和，我们可以利用比特串计数  $c(z^{\prime}_{i})$  将求和改写为对所有可能比特串的求和。这样做后，我们最终得到IBU更新规则：

$$
\begin{array}{r l} & {\theta_{j}^{k + 1} = \sum_{i = 1}^{2^{n}}\frac{c(z^{\prime}_{i})}{S}\cdot \frac{P(z^{\prime}_{i}|z_{j})P_{\theta^{k}}(z_{j})}{\sum_{m}P(z^{\prime}_{i}|z_{m})P_{\theta^{k}}(z_{m})}}\\ & {\quad = \sum_{i = 1}^{2^{n}}P_{i}\cdot \frac{P(z^{\prime}_{i}|z_{j})P_{\theta^{k}}(z_{j})}{\sum_{m}P(z^{\prime}_{i}|z_{m})P_{\theta^{k}}(z_{m})}} \end{array} \tag{A7}
$$

其中  $\begin{array}{r}p_{i} = \frac{c(z^{\prime}_{i})}{S} \end{array}$  表示观测比特串  $z^{\prime}_{i}$  出现的频率,  $R_{ij} = P(z^{\prime}_{i}|z_{j})$  表示从真实比特串  $z_{j}$  观测到 $z^{\prime}_{i}$  的概率。