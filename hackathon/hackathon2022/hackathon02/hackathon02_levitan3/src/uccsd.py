# -*- coding: utf-8 -*-
# Copyright 2021 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""UCCSD ansatz."""

from collections import OrderedDict as ordict
import itertools
import numpy as np
from openfermion.chem import MolecularData
from mindquantum.core.operators import FermionOperator
from mindquantum.core.operators.utils import down_index, up_index, get_fermion_operator
from mindquantum.algorithm.nisq.chem.transform import Transform
from mindquantum.third_party.interaction_operator import InteractionOperator
from mindquantum.core.circuit.utils import decompose_single_term_time_evolution
from mindquantum.core.circuit import Circuit


def _para_uccsd_singlet_generator(mol, th=0):
    """
    Generate a uccsd quantum circuit.

    Args:
        mol (molecular): A hdf5 molecular file generated by HiQ Fermion.
        th (int, optional): A threadhold of parameters. If a parameter is
            lower than the threadhold, than we will not update it in VQE
            algorithm. Default: 0.
    """
    n_qubits = mol.n_qubits
    n_electrons = mol.n_electrons
    params = {}
    if n_qubits % 2 != 0:
        raise ValueError('The total number of spin-orbitals should be even.')
    out = []
    out_tmp = []
    n_spatial_orbitals = n_qubits // 2
    n_occupied = int(np.ceil(n_electrons / 2))
    n_virtual = n_spatial_orbitals - n_occupied
    count = 0
    if n_electrons in [2,10,18,28]:
        strong = True
    else:
        strong = False
    # amps = list(set(np.abs(mol.ccsd_single_amps.reshape(-1).tolist() + mol.ccsd_double_amps.reshape(-1).tolist())))
    # max_amps = sorted(amps)[-80:]
    # max_amps = sorted(amps)
    # print(mol.ccsd_single_amps)
    # Unpack amplitudes
    n_single_amplitudes = n_occupied * n_virtual
    # Generate excitations
    spin_index_functions = [up_index, down_index]
    # Generate all spin-conserving single and double excitations derived
    # from one spatial occupied-virtual pair
    if n_electrons%2 == 0:
        use_spin = 1
    else:
        use_spin = 2
    for i, (p, q) in enumerate(
            itertools.product(range(n_virtual), range(n_occupied))):

        # Get indices of spatial orbitals
        virtual_spatial = n_occupied + p
        occupied_spatial = q
        virtual_up = virtual_spatial * 2
        occupied_up = occupied_spatial * 2
        virtual_down = virtual_spatial * 2 + 1
        occupied_down = occupied_spatial * 2 + 1
        single_amps = mol.ccsd_single_amps[virtual_up, occupied_up]
        double1_amps = mol.ccsd_double_amps[virtual_up, occupied_up,
                                            virtual_down, occupied_down]
        single_amps_name = 'p' + str(i)
        double1_amps_name = 'p' + str(i + n_single_amplitudes)
        
        for spin in range(2):
            # Get the functions which map a spatial orbital index to a
            # spin orbital index
            this_index = spin_index_functions[spin]
            other_index = spin_index_functions[1 - spin]

            # Get indices of spin orbitals
            virtual_this = this_index(virtual_spatial)
            virtual_other = other_index(virtual_spatial)
            occupied_this = this_index(occupied_spatial)
            occupied_other = other_index(occupied_spatial)

            # Generate single excitations
            if abs(single_amps) > th :
                count+=1
                # print(count,'single',(virtual_spatial, occupied_spatial),(virtual_this,occupied_this), single_amps)
                params[single_amps_name] = single_amps
                fermion_ops1 = FermionOperator(
                    ((occupied_this, 1), (virtual_this, 0)), 1)
                fermion_ops2 = FermionOperator(
                    ((virtual_this, 1), (occupied_this, 0)), 1)
                out.append([fermion_ops1 - fermion_ops2, single_amps_name])

            # Generate double excitation
            if abs(double1_amps) > th:
            # if abs(double1_amps) > th and spin==0:
                count+=1
                # print(count, 'double',(virtual_spatial, occupied_spatial),(virtual_this, occupied_this,
                                            # virtual_other, occupied_other), double1_amps)
                if strong:
                    if spin!=0:
                        continue
                    else:
                        params[double1_amps_name] = 2*double1_amps
                else:
                    params[double1_amps_name] = double1_amps
                fermion_ops1 = FermionOperator(
                    ((virtual_this, 1), (occupied_this, 0), (virtual_other, 1),
                     (occupied_other, 0)), 1)
                fermion_ops2 = FermionOperator(
                    ((occupied_other, 1), (virtual_other, 0),
                     (occupied_this, 1), (virtual_this, 0)), 1)
                out.append([fermion_ops1 - fermion_ops2, double1_amps_name])
                # print(fermion_ops1 - fermion_ops2, virtual_spatial,occupied_spatial, spin)
    out.extend(out_tmp)
    out_tmp = []
    # Generate all spin-conserving double excitations derived
    # from two spatial occupied-virtual pairs
    set_list = []
    for i, ((p, q), (r, s)) in enumerate(
            itertools.combinations(
                itertools.product(range(n_virtual), range(n_occupied)), 2)):

        # Get indices of spatial orbitals
        virtual_spatial_1 = n_occupied + p
        occupied_spatial_1 = q
        virtual_spatial_2 = n_occupied + r
        occupied_spatial_2 = s

        virtual_1_up = virtual_spatial_1 * 2
        occupied_1_up = occupied_spatial_1 * 2
        virtual_2_up = virtual_spatial_2 * 2 + 1
        occupied_2_up = occupied_spatial_2 * 2 + 1

        double2_amps = mol.ccsd_double_amps[virtual_1_up, occupied_1_up,
                                            virtual_2_up, occupied_2_up]
        double2_amps_name = 'p' + str(i + 2 * n_single_amplitudes)

        # Generate double excitations
        for (spin_a, spin_b) in itertools.product(range(2), repeat=2):
            # Get the functions which map a spatial orbital index to a
            # spin orbital index
            index_a = spin_index_functions[spin_a]
            index_b = spin_index_functions[spin_b]

            # Get indices of spin orbitals
            virtual_1_a = index_a(virtual_spatial_1)
            occupied_1_a = index_a(occupied_spatial_1)
            virtual_2_b = index_b(virtual_spatial_2)
            occupied_2_b = index_b(occupied_spatial_2)
            # if virtual_1_a==virtual_2_b or occupied_1_a==occupied_2_b:
            #     continue
            dflag = False
            # if spin_a != spin_b:
            #     if set([virtual_spatial_1,virtual_spatial_2,q,s]) in set_list:
            #         continue
            #     else:
            #         set_list.append(set([virtual_spatial_1,virtual_spatial_2,q,s]))
            #         dflag = True
            
            if abs(double2_amps) > th:
                count+=1
                # print(count, 'cross',(virtual_1_up, occupied_1_up,virtual_2_up, occupied_2_up), (virtual_1_a,occupied_1_a,virtual_2_b, occupied_2_b), double2_amps)
                if dflag:
                    params[double2_amps_name] = 2*double2_amps
                else:
                    params[double2_amps_name] = double2_amps
                fermion_ops1 = FermionOperator(
                    ((virtual_1_a, 1), (occupied_1_a, 0), (virtual_2_b, 1),
                     (occupied_2_b, 0)), 1)
                fermion_ops2 = FermionOperator(
                    ((occupied_2_b, 1), (virtual_2_b, 0), (occupied_1_a, 1),
                     (virtual_1_a, 0)), 1)
                out.append([fermion_ops1 - fermion_ops2, double2_amps_name])
                # print(fermion_ops1, virtual_spatial_1,virtual_spatial_2,q,s, (spin_a, spin_b))
    return out, params


def _transform2pauli(fermion_ansatz):
    """
    Transform a fermion ansatz to pauli ansatz based on jordan-wigner
    transformation.
    """
    out = ordict()
    for i in fermion_ansatz:
        qubit_generator = Transform(i[0]).jordan_wigner()
        if qubit_generator.terms != {}:
            for key, term in qubit_generator.terms.items():
                # print('key',key, term)
                if key not in out:
                    out[key] = ordict({i[1]: float(term.imag)})
                else:
                    if i[1] in out[key]:
                        out[key][i[1]] += float(term.imag)
                    else:
                        out[key][i[1]] = float(term.imag)
    return out

def _transform2pauli_sym(fermion_ansatz):
    """
    Transform a fermion ansatz to pauli ansatz based on jordan-wigner
    transformation.
    """
    out = ordict()
    sym = ordict()
    for i in fermion_ansatz:
        qubit_generator = Transform(i[0]).jordan_wigner()
        if qubit_generator.terms != {}:
            for key, term in qubit_generator.terms.items():
                # print('key',key, term)
                sval = float(term.imag)
                if sval > 0:
                    sign = 1
                else:
                    sign = -1
                skey = tuple(sorted(np.array(key).reshape(-1)) + [sign])
                if skey not in sym:
                    sym[skey] = ordict({i[1]: key, 'val': sval})
                # if key not in out:
                    out[key] = ordict({i[1]: float(term.imag)}) 
                elif i[1] not in sym[skey]:
                    out[key] = ordict({i[1]: float(term.imag)}) 
                else:
                    idkey = sym[skey][i[1]]
                    if i[1] in out[idkey]:
                        out[idkey][i[1]] += float(term.imag)
                    else:
                        out[idkey][i[1]] = float(term.imag)
    return out

def _pauli2circuit(pauli_ansatz):
    """Transform a pauli ansatz to parameterized quantum circuit."""
    circuit = Circuit()
    count = 0
    for k, v in pauli_ansatz.items():
        # print(k, v)
        # count+=1
        # if count>3:
        #     break
        circuit += decompose_single_term_time_evolution(k, v)
        # circuit += new_decompose_single_term_time_evolution(k, v)
    # print(circuit)
    return circuit

def new_decompose_single_term_time_evolution(term, para):
    """
    Decompose a time evolution gate into basic quantum gates.

    This function only work for the hamiltonian with only single pauli word.
    For example, exp(-i * t * ham), ham can only be a single pauli word, such
    as ham = X0 x Y1 x Z2, and at this time, term will be
    ((0, 'X'), (1, 'Y'), (2, 'Z')). When the evolution time is expressd as
    t = a*x + b*y, para would be {'x':a, 'y':b}.

    Args:
        term (tuple, QubitOperator): the hamiltonian term of just the
            evolution qubit operator.
        para (Union[dict, numbers.Number]): the parameters of evolution operator.

    Returns:
        Circuit, a quantum circuit.

    Raises:
        ValueError: If term has more than one pauli string.
        TypeError: If term is not map.

    Example:
        >>> from mindquantum.core.operators import QubitOperator
        >>> from mindquantum.core.circuit import decompose_single_term_time_evolution
        >>> ham = QubitOperator('X0 Y1')
        >>> circuit = decompose_single_term_time_evolution(ham, {'a':1})
        >>> print(circuit)
        q0: ─────H───────●───────────────●───────H──────
                         │               │
        q1: ──RX(π/2)────X────RZ(2*a)────X────RX(7π/2)──
    """
    from mindquantum import gates as G
    from mindquantum.core.circuit import Circuit
    from mindquantum.core.parameterresolver import ParameterResolver as PR
    from mindquantum.core.parameterresolver.parameterresolver import ParameterResolver
    from mindquantum.utils.type_value_check import _num_type
    if not isinstance(term, tuple):
        try:
            if len(term.terms) != 1:
                raise ValueError("Only work for single term time \
                    evolution operator, but get {}".format(len(term)))
            term = list(term.terms.keys())[0]
        except TypeError:
            raise TypeError("Not supported type:{}".format(type(term)))
    if not isinstance(para, _num_type):
        if not isinstance(para, (dict, ParameterResolver)):
            raise TypeError(f'para requiers a number or a dict or a ParameterResolver, but get {type(para)}')
        para = ParameterResolver(para)

    out = []
    term = sorted(term)
    rxs = []
    if len(term) == 1:  # single pauli operator
        if term[0][1] == 'X':
            out.append(G.RX(para * 2).on(term[0][0]))
        elif term[0][1] == 'Y':
            out.append(G.RY(para * 2).on(term[0][0]))
        else:
            out.append(G.RZ(para * 2).on(term[0][0]))
    else:
        for index, action in term:
            if action == 'X':
                out.append(G.H.on(index))
            elif action == 'Y':
                rxs.append(len(out))
                out.append(G.RX(np.pi / 2).on(index))

        out.append(G.BarrierGate(False))
        # for i in range(len(term) - 1):
        #     out.append(G.X.on(term[i + 1][0], term[i][0]))
        if len(term)%2==0:
            #even qubits
            for i in range(int(len(term)/2)):
                out.append(G.X.on(term[2*i + 1][0], term[2*i][0]))
            for i in range(int(len(term)/2 - 1)):
                out.append(G.X.on(term[2*i + 2][0], term[2*i+1][0]))
        else:
            #odd qubits
            for i in range(int(len(term)/2)):
                out.append(G.X.on(term[2*i + 1][0], term[2*i][0]))
            for i in range(int(len(term)/2)):
                out.append(G.X.on(term[2*i + 2][0], term[2*i+1][0]))

        out.append(G.BarrierGate(False))
        if isinstance(para, (dict, PR)):
            out.append(G.RZ({i: 2 * j for i, j in para.items()}).on(term[-1][0]))
        else:
            out.append(G.RZ(2 * para).on(term[-1][0]))
        for i in range(len(out) - 1)[::-1]:
            if i in rxs:
                out.append(G.RX(np.pi * 3.5).on(out[i].obj_qubits))
            else:
                out.append(out[i])
    return Circuit(out)

def generate_uccsd(molecular, th=0):
    """
    Generate a uccsd quantum circuit based on a molecular data generated by
    HiQfermion or openfermion.

    Args:
        molecular (Union[str, MolecularData]): the name of the molecular data file,
            or openfermion MolecularData.
        th (int): the threshold to filt the uccsd amplitude. When th < 0, we
            will keep all amplitudes. When th == 0, we will keep all amplitude
            that are positive. Default: 0.

    Returns:
        - **uccsd_circuit** (Circuit), the ansatz circuit generated by uccsd method.
        - **initial_amplitudes** (numpy.ndarray), the initial parameter values of uccsd circuit.
        - **parameters_name** (list[str]), the name of initial parameters.
        - **qubit_hamiltonian** (QubitOperator), the hamiltonian of the molecule.
        - **n_qubits** (int), the number of qubits in simulation.
        - **n_electrons**, the number of electrons of the molecule.
    """
    if isinstance(molecular, str):
        mol = MolecularData(filename=molecular)
        mol.load()
    else:
        mol = molecular
    print("ccsd:{}.".format(mol.ccsd_energy))
    print("fci:{}.".format(mol.fci_energy))
    fermion_ansatz, parameters = _para_uccsd_singlet_generator(mol, th)
    pauli_ansatz = _transform2pauli(fermion_ansatz)
    uccsd_circuit = _pauli2circuit(pauli_ansatz)
    ham_of = mol.get_molecular_hamiltonian()
    inter_ops = InteractionOperator(*ham_of.n_body_tensors.values())
    ham_hiq = get_fermion_operator(inter_ops)
    qubit_hamiltonian = Transform(ham_hiq).jordan_wigner()
    qubit_hamiltonian.compress()

    parameters_name = list(parameters.keys())
    initial_amplitudes = [parameters[i] for i in parameters_name]
    return uccsd_circuit, \
        initial_amplitudes, \
        parameters_name, \
        qubit_hamiltonian, \
        mol.n_qubits, \
        mol.n_electrons

if __name__ == "__main__":
    from mindquantum.core.operators import QubitOperator
    ham = QubitOperator('X0 Y1 X2 Z3')
    circuit = new_decompose_single_term_time_evolution(ham, {'a':1})
    print(circuit)